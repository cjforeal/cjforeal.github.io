<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="cjforeal">





<title>写给自己的Game101总结 | Cjforeal(鼻屎拌饭)</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">cj&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">cj&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">写给自己的Game101总结</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">cjforeal</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十月 24, 2022&nbsp;&nbsp;22:04:33</a>
                        </span>
                    
                     


                    
                        <span class="post-count">
                    Words:
                            <a href="">4.4k</a> 
                        </span>
                    

                    
                    
                        <span class="post-count">
                    Time:
                            <a href="">18min</a> 
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><ol>
<li><p>点乘<br>$$<br>\vec{a}\vec{b}&#x3D;|a||b|cos\theta<br>$$<br> 用途：求角度或者投影,两个向量多么接近，以及两个向量的前后关系</p>
</li>
<li><p>叉乘<br>$$<br>|\vec{a}\times\vec{b}|&#x3D;||a|||b||sin\theta<br>$$<br>用途：得到垂直于 a，b两向量构成的面的 向量，并且叉乘的模是两向量平行四边形的面积。可以判断两向量内外或者左右关系。  </p>
<p>例如<img src="/images%5Cgame101%E5%8F%89%E4%B9%98.png" alt="game101叉乘"></p>
<p>如何判断B在A的左侧？</p>
<p>可以A叉乘B，看得到向量是正还是负，再通过右手螺旋定则，就可以了。</p>
<p>这是一个二维生三维的升变公式。</p>
<p>AB叉AP,BC叉BP,CA叉CP  三者结果若全都一个方向则在内部，反之不在</p>
<p>平面坐标中，如何判断P点在ABC内部？</p>
<p>注意：得到的向量的方向满足于右手螺旋定则(某些的图形Api可能选左手，视情况定)，因此叉乘不满足交换律，因为结果向量的方向不同。</p>
</li>
</ol>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><ol>
<li>矩阵乘法，不存在交换律，结合律分配律存在</li>
</ol>
<p>  <img src="/images%5C%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95.pnsg" alt="image-20221024233926616"></p>
<ol start="2">
<li><p>矩阵转置<br>$$<br>(AB)^T &#x3D;B^TA^t<br>$$</p>
</li>
<li><p>单位矩阵，矩阵的逆 忘了的话就看线代；</p>
</li>
</ol>
<h3 id="二维变换"><a href="#二维变换" class="headerlink" title="二维变换"></a>二维变换</h3><h4 id="线性变换-Linear-Transforms"><a href="#线性变换-Linear-Transforms" class="headerlink" title="线性变换(Linear Transforms)"></a>线性变换(Linear Transforms)</h4><p><strong>如果可以用一个相同维度的矩阵乘以你的输入坐标得到输出坐标，那我们就认为这是线性变换。</strong>例如旋转，缩放。</p>
<p>求线性变换公式规则是什么？举一个求旋转矩阵公式的例子</p>
<p><img src="/images%5C%E5%8F%98%E6%8D%A2%E6%97%8B%E8%BD%AC.png" alt="变换旋转"></p>
<p><em><strong>注意 这里是绕原点逆时针旋转</strong></em></p>
<p>图中物体旋转，所有点都满足相同的旋转公式，所以可以找特殊点推导其旋转公式<br>$$<br>假设四边长皆为1，逆时针旋转\theta， 则右下角坐标变为，(cos\theta,sin\theta)，存在<br>$$</p>
<p>$$<br>\begin{bmatrix}<br>xˋ\<br>yˋ<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>a&amp;b\<br>c&amp;d<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\<br>y<br>\end{bmatrix}<br>带入 x&#x3D;1,y&#x3D;0 ,xˋ&#x3D;cos\theta,xˋ&#x3D;sin\theta<br>$$</p>
<p>则有<br>$$<br>a+b<em>0&#x3D;cos\theta ,c+d</em>0&#x3D;sin\theta<br>$$</p>
<p>即求出 a和c ，同样我们再带入第二个点，比如左上角(-sin theta,cos theta)，即可求出 b，d<br>$$<br>\begin{bmatrix}<br>xˋ\<br>yˋ<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>cos\theta&amp;-sin\theta\<br>sin\theta&amp;cos\theta<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\<br>y<br>\end{bmatrix}<br>$$<br><strong>Attention：</strong><em><strong>旋转矩阵是正交矩阵，逆矩阵与转置矩阵相同</strong></em>，带入个顺时针旋转theta角就明白了</p>
<p>也可以这样理解 ：<strong>旋转矩阵中的值即为x,y轴的单位向量旋转后的值，三维也是同样的</strong></p>
<p>没必要记，毕竟容易推导；举一反三，什么对称，缩放，切变公式也就往后稍稍了；</p>
<h4 id="齐次坐标-Homogeneous-Coordinates"><a href="#齐次坐标-Homogeneous-Coordinates" class="headerlink" title="齐次坐标(Homogeneous Coordinates)"></a>齐次坐标(Homogeneous Coordinates)</h4><p>为什么齐次坐标？</p>
<p>当我们想着把平移用矩阵的形式表示时，公式是<br>$$<br>\begin{bmatrix}<br>xˋ\<br>yˋ<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>1&amp;0\<br>0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\<br>y<br>\end{bmatrix}<br>+<br>\begin{bmatrix}<br>t_x\<br>t_y<br>\end{bmatrix}<br>$$<br><em><strong>所以平移并不是线性变换</strong></em>,这是一种仿射变换(Affine Transformations)。</p>
<p>我们不想要平移成为特例，而是想着把平移旋转缩放等一起概括，所有有了齐次坐标。</p>
<p><strong>齐次坐标</strong></p>
<p><strong>二维坐标中，我们人为的加入了第三个坐标 w，并且定义为 w只能&#x3D;1或0;</strong></p>
<p><strong>如果w&#x3D;1，坐标表示为2D的一个点，若等于0，则表示2D向量。</strong></p>
<p>因此如果我们用齐次坐标来表示平移时，就会有以下式子<br>$$<br>\begin{bmatrix}<br>xˋ\<br>yˋ\<br>wˋ<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>1&amp;0&amp;t_x\<br>0&amp;1&amp;t_y\<br>0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\<br>y\<br>1<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>x+t_x\<br>y+t_y\<br>1<br>\end{bmatrix}<br>$$<br>发现仅用矩阵乘法就可以很好的表示位移，就很舒服。****</p>
<p>w的定义规则有一定原因</p>
<ol>
<li><p>为了保证向量不变性，即不管怎么平移向量，向量大小即方向不改变，我们使其w&#x3D;0</p>
</li>
<li><p>为了符合点与点之间，向量与向量之间，点与向量之间的运算关系</p>
<table>
<thead>
<tr>
<th>vector+vector&#x3D;vector</th>
<th></th>
<th>向量之和仍为向量 其中w一直是0</th>
</tr>
</thead>
<tbody><tr>
<td>vector+point&#x3D;vector</td>
<td></td>
<td>点加向量表示点的平移，w&#x3D;1+0&#x3D;1符合</td>
</tr>
<tr>
<td>point-point&#x3D;vector</td>
<td></td>
<td>两点之差为向量，w&#x3D;1-1&#x3D;0符合</td>
</tr>
<tr>
<td>那两点之和是什么？</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>有一点point(x,y,w)，我们将w转为1，同时除以w得point(x&#x2F;w,y&#x2F;w,1)，加上另外一点(x`&#x2F;w,y`&#x2F;w,1)两点相加后得到<br>$$<br>\frac{x+x<code>&#125;&#123;w&#125;, \frac&#123;y+y</code>}{w},<br>2<br>$$</p>
<p>w仍要为1，所以再除以2得到<br>$$<br>\frac{x+x<code>&#125;&#123;2w&#125;, \frac&#123;y+y</code>}{2w},<br>1<br>$$<br>显然，得到了一个中点。</p>
<p><strong>所以在齐次坐标中，两点相加表示两点的中点.</strong></p>
<p>并且齐次坐标系下，点乘以任一非零实数仍为相同的点。</p>
</li>
</ol>
<p>在齐次坐标下的缩放旋转和平移</p>
<p><img src="/images%5C%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E8%A1%A8%E7%A4%BA.png" alt="齐次坐标表示"></p>
<h4 id="组合变换"><a href="#组合变换" class="headerlink" title="组合变换"></a>组合变换</h4><p><img src="/images%5C%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2.png" alt="组合变换"></p>
<p>如图，显然这个物体是经过两次变换到新二张图，又由于矩阵乘法不满足交换律，所以是先旋转还是先平移就会有区别。</p>
<p>通过计算得知，先旋转再平移是符合结果的；<br>$$<br>T_{(1,0)}\cdot R_{45}<br>\begin{bmatrix}<br>x\<br>y\<br>1<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>1&amp;0&amp;1\<br>0&amp;1&amp;0\<br>0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>cos45&amp;-sin45&amp;0\<br>sin45&amp;cos45&amp;0\<br>0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\<br>y\<br>1<br>\end{bmatrix}<br>$$<br><em><strong>注意，组合变换公式的计算顺序是从右到左的，即先把输入坐标与右一 到右二 直到左一3x3矩阵逐个计算</strong></em></p>
<p>当然，矩阵乘法满足结合律1，我们也可以先计算所有变换矩阵，再把其结果与输入坐标进行计算。</p>
<p><strong>当我们要绕非原点进行旋转时一般是将图形平移到旋转点为原点，再绕原点旋转，然后再平移回去即可</strong></p>
<p>组合变换表示为<br>$$<br>T_{(c)}\cdot R_{(\theta)}\cdot T_{(-c)}<br>$$</p>
<h3 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h3><p>右手坐标系的情况下。</p>
<p>多了一个维度Z，其他与二维变换同样，齐次坐标规则也一致<br>$$<br>3D<br>point &#x3D;(x,y,z,1)<br>$$</p>
<p>$$<br>3D \ vector &#x3D;(x,y,z,0)<br>$$</p>
<p>w为一表示点，为0表示向量</p>
<h4 id="旋转矩阵表示"><a href="#旋转矩阵表示" class="headerlink" title="旋转矩阵表示"></a>旋转矩阵表示</h4><p>即绕三个轴旋转，这里先只考虑绕单个轴旋转，</p>
<ul>
<li><p>点绕x轴旋转，即点 x轴坐标不变(则第一行为1，0，0，0)，且y，z旋转后坐标与x轴无关(则第一列为1,0,0,0),当然也可以选择几个特殊点计算求得，所以其旋转矩阵可写为<br>$$<br>R_{x}(\alpha)&#x3D;<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;0\<br>0&amp;cos\alpha&amp;-sin\alpha&amp;0\<br>0&amp;sin\alpha&amp;cos\alpha&amp;0\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p>
</li>
<li><p>点绕z轴旋转，同上规则<br>$$<br>R_{z}(\alpha)&#x3D;<br>\begin{bmatrix}<br>cos\alpha&amp;-sin\alpha&amp;0&amp;0\<br>sin\alpha&amp;cos\alpha&amp;0&amp;0\<br>0&amp;0&amp;1&amp;0\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p>
</li>
<li><p>点绕y轴旋转有些不同,我的理解就是，绕y轴逆时针旋转对于xz平面其实是顺时针旋转，所以应为-alpha<br>$$<br>R_{z}(\alpha)&#x3D;<br>\begin{bmatrix}<br>cos\alpha&amp;0&amp;sin\alpha&amp;0\<br>0&amp;1&amp;0&amp;0\<br>-sin\alpha&amp;0&amp;cos\alpha&amp;0\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$<br>所以三维空间内任意一个绕任意轴的旋转都可以由绕xyz旋转组合而成。<br>$$<br>R_{(\vec{n},\alpha)}&#x3D;R_{(\vec{x},\alpha x)}\cdot R_{(\vec{y},y\alpha)}\cdot R_{(\vec{z},\alpha z)}<br>$$<br>而由于其分解和运算的过程很麻烦，就有了罗德里格斯旋转方程。</p>
</li>
</ul>
<h4 id="罗德里格斯旋转方程-Rodrigues"><a href="#罗德里格斯旋转方程-Rodrigues" class="headerlink" title="罗德里格斯旋转方程(Rodrigues)"></a>罗德里格斯旋转方程(Rodrigues)</h4><p>PASS~</p>
<h3 id="三维到二维"><a href="#三维到二维" class="headerlink" title="三维到二维"></a>三维到二维</h3><p>从三维到二维有一个既定的过程，举一个现实中的栗子，摆拍</p>
<p>摆拍首先得把人和物带到拍照的位置，这就是<strong>模型变换(Model Transformation)</strong>.</p>
<p>摆好相机的位置和相机的朝向，这就是 <strong>视图变换(View Transformation)</strong>.</p>
<p>然后开始拍照，就存在一个三维到二维投影的过程，这就是<strong>投影变换(Projection Transformation)</strong>.</p>
<p> 三个合称<strong>MVP变换</strong>，得到的结果为<strong>MVP变换矩阵</strong>。</p>
<h4 id="视图变换"><a href="#视图变换" class="headerlink" title="视图变换"></a>视图变换</h4><p>视图变换目的在于把所有物体变换到目标位置。这里得变换矩阵是根据<strong>摄像机</strong>变换得来的。</p>
<p>相机基础属性有三个：</p>
<ol>
<li>位置 <strong>e</strong>(x,y,z)</li>
<li>朝向 <strong>g</strong></li>
<li>相对相机的正上方向量  <strong>t</strong></li>
</ol>
<p>我们要摆放相机，这里有一个约定俗成的规定：</p>
<p>相机位置位于（0，0，0），朝向为-<strong>z</strong>(0,0,-1)  ，正上方向量为<strong>y</strong>(0,1,0)，</p>
<p>为什么，因为好处多多，留到以后再说</p>
<p>所以我们需要进行以下变换</p>
<ul>
<li>将相机坐标<strong>e</strong>平移到原点</li>
<li>旋转<strong>g</strong>到**-z**</li>
<li>旋转<strong>t</strong>到<strong>y</strong></li>
<li>旋转<strong>g × t</strong> 到 <strong>x</strong>(1,0,0)</li>
</ul>
<p>首先平移矩阵最好写<br>$$<br>T_{(VIEW)}&#x3D;<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;-x_e\<br>0&amp;1&amp;0&amp;-y_e\<br>0&amp;0&amp;1&amp;-z_e\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$<br> 然后就是三个旋转，</p>
<p>这里为了计算方便：选择逆向思维，我们先求-z到g，y到t，x到g x t的 这三个单位向量的旋转矩阵，得到的结果组合起来就是目标旋转矩阵的逆矩阵，然后又因为旋转矩阵是正交矩阵，所以将结果转置，就是我们要的目标矩阵了.</p>
<p>又因为，旋转矩阵中的值即为x,y,z三个轴的单位向量旋转后的值</p>
<p>所以计算结果逆矩阵为<br>$$<br>R_{VIEW}^{-1}&#x3D;<br>\begin{bmatrix}<br>x_{\vec{g}\times\vec{t}}&amp;x_\vec{t}&amp;x_{-\vec{g}}&amp;0\<br>y_{\vec{g}\times\vec{t}}&amp;y_\vec{t}&amp;y_{-\vec{g}}&amp;0\<br>z_{\vec{g}\times\vec{t}}&amp;z_\vec{t}&amp;z_{-\vec{g}}&amp;0\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$<br>转置一下就是目标旋转矩阵了<br>$$<br>R_{VIEW}&#x3D;<br>\begin{bmatrix}<br>x_{\vec{g}\times\vec{t}}&amp;y_{\vec{g}\times\vec{t}}&amp;z_{\vec{g}\times\vec{t}}&amp;0\<br>x_\vec{t}&amp;y_\vec{t}&amp;z_\vec{t}&amp;0\<br>x_{-\vec{g}}&amp;y_{-\vec{g}}&amp;z_{-\vec{g}}&amp;0\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p>
<p>所以<strong>视图变换矩阵</strong>为<br>$$<br>R_{VIEW}T_{(VIEW)}&#x3D;<br>\begin{bmatrix}<br>x_{\vec{g}\times\vec{t}}&amp;y_{\vec{g}\times\vec{t}}&amp;z_{\vec{g}\times\vec{t}}&amp;0\<br>x_\vec{t}&amp;y_\vec{t}&amp;z_\vec{t}&amp;0\<br>x_{-\vec{g}}&amp;y_{-\vec{g}}&amp;z_{-\vec{g}}&amp;0\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;-x_e\<br>0&amp;1&amp;0&amp;-y_e\<br>0&amp;0&amp;1&amp;-z_e\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p>
<h4 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h4><p>投影变换分为两种</p>
<ul>
<li>正交投影（Orthographic projection）</li>
<li>透视投影（Perspective     projection）</li>
</ul>
<p>两者共有的属性</p>
<ul>
<li><p>Near clip plane 和Far clip plane</p>
<p>两者分别代表摄像机看见的最近平面和最远平面，两平面间的空间就是我们能看见的</p>
<p>正交投影为这个空间近似于长方体，透视投影则时像个椎体，成为视锥体</p>
</li>
<li><p>由于之前的视图变化，使得计算更加简便</p>
</li>
<li><p>摄像机看向z还是-z不同图形软件可能不同，如opengl就是右手坐标系，unity是左手坐标系</p>
<p>投影变换判断前后时若再右手坐标系下，越近的物体，z越大。</p>
</li>
</ul>
<p>之前开发2d游戏时对于视角的探索已经让我对两者有了很清晰的认识，现在来学习怎么实现的</p>
<h5 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h5><p><img src="/images%5C%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1.png" alt="正交投影"></p>
<p>如图 正交投影的特点是没有透视关系，近切面与远切面大小相同。</p>
<p>而它的投影过程通俗来讲的话，就是一个压缩的过程：</p>
<p>可视空间内的物体x,y坐标不变，将z坐标舍弃，形成一个二维平面，再将平面移动拉伸到一个左下角为(-1,-1),右上角为（1，1）的矩形中。</p>
<p><em>为什么要映射在-1<del>1的矩形内，这是一个约定俗成的东西，相当于我们拍照，规定洗出的照片都得是2×2大小的，学opengl时学到一个标准化设备坐标系，范围也是-1</del>1，两者也对应起来了。</em></p>
<p>规范点说法是：将上诉摄像机所观测的空间（即长方体，设为 S ）变换成一个<strong>标准立方体</strong>（<strong>canonical cube</strong>）。</p>
<p>何为标准立方体？即以原点为中心，边长为2的立方体，也就是立方形在x，y，z三个轴上都是从-1到1。</p>
<p>整个变换过程就是我们的<strong>正交投影变换</strong>，其对应矩阵即为正交投影变换矩阵。该变换我们可以分为如下两步（这也体现了视图变换的重要性，使得我们做投影变换变得很简单）：</p>
<ol>
<li>平移变换，将长方体S平移到原点。</li>
<li>缩放变换，将长方体S的长宽高缩放成2</li>
</ol>
<p>所以有正交投影变换矩阵（r,l,t,b,n,f 两两成对，分别为  近切面x,y,z最小及最大坐标）;<br>$$<br>M_{ortho}&#x3D;<br>\begin{bmatrix}<br>\frac{2}{r-l}&amp;0&amp;0&amp;-x_e\<br>0&amp;\frac{2}{t-b}&amp;0&amp;-y_e\<br>0&amp;0&amp;\frac{2}{n-f}&amp;-z_e\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;-\frac{r+l}{2}\<br>0&amp;1&amp;0&amp;-\frac{t+b}{2}\<br>0&amp;0&amp;1&amp;-\frac{n+f}{2}\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p>
<p><em>这里遗留了一个问题：没了z坐标 ，怎么判断物体的前后？</em></p>
<h5 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h5><p><img src="/images%5C%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1.png" alt="透视投影"></p>
<p>与正交投影不同的是，透视投影会有近大远小的现象，这种投影更有真实感。从图中我们可以看出远切面要大于近切面，因此我们摄像机所观测的区域不再是一个长方体，而是变成了一个四棱台（即四棱锥去掉顶部），也就是我们常说的<strong>视锥体</strong>（Frustum）。</p>
<p>所以透视投影是个什么过程呢？</p>
<p>它分为两个过程</p>
<ul>
<li>第一步是将视锥体压缩成长方体的过程</li>
<li>第二步是对长方体执行正交投影变换的过程、</li>
</ul>
<p>那么我们只需要计算出第一步的变换矩阵，然后将它乘以正交投影变换矩阵，即可得到我们的透视投影变换矩阵了。</p>
<p>第一步个人理解就相当于把视锥体切分成n个截面，把每一个截面都压缩成近切面的大小。</p>
<p>第一步有以下规定，</p>
<ul>
<li>近切面永远是不变的，四个顶点都是设置好的常量</li>
<li>远切面的z值不论变换前后都是不变的。</li>
<li>透视中心点是不会变化的</li>
</ul>
<p>所以该如何挤压呢？我们以挤压y坐标为例</p>
<p><img src="/images%5Cy%E5%9D%90%E6%A0%87%E6%8A%95%E5%BD%B1.png" alt="y坐标投影"></p>
<p>如图，去需要压缩面上的一点（x,y,z）其再近切面上的对应点为（x`,y`,z`）,设摄像机到近切面的距离为n(已知常量)，</p>
<p>我们要求y`的表达式，这里有很明显的一对相似三角形，存在关系<br>$$<br>y<code>=\frac&#123;n&#125;zy $$ 同样的道理，对xz切面作近似三角形，得出x</code>的表达式<br>$$<br>x&#96;&#x3D;\frac{n}zx<br>$$</p>
<p>因此在齐次坐标下就有了如下转换过程<br>$$<br>\begin{pmatrix}<br>x\<br>y\<br>z\<br>1<br>\end{pmatrix}<br>&#x3D;&gt;^{相似}<br>\begin{pmatrix}<br>\frac{n}zx\<br>\frac{n}zy\<br>?\<br>1<br>\end{pmatrix}<br>&#x3D;&gt;^{*z}<br>\begin{pmatrix}<br>nx\<br>ny\<br>?\<br>z<br>\end{pmatrix}<br>$$<br><em>为什么想到要同时乘z，因为z是变量</em></p>
<p><em>有个问题，z坐标压缩后不应该还是z吗？怎么不知道？留待后面说，实际会变大</em></p>
<p>所以也就存在一个4x4的变换矩阵使得<br>$$<br>M_{persp-&gt;ortho}^{4×4}<br>\begin{pmatrix}<br>x\<br>y\<br>z\<br>1<br>\end{pmatrix}<br>&#x3D;<br>\begin{pmatrix}<br>nx\<br>ny\<br>?\<br>z<br>\end{pmatrix}<br>$$<br>计算得到该矩阵<br>$$<br>M_{persp-&gt;ortho}^{4×4}&#x3D;<br>\begin{pmatrix}<br>n&amp;0&amp;0&amp;0\<br>0&amp;n&amp;0&amp;0\<br>?&amp;?&amp;?&amp;?\<br>0&amp;0&amp;1&amp;0<br>\end{pmatrix}<br>。。。。。。<br>可以是这个<br>\begin{pmatrix}<br>n&amp;0&amp;0&amp;0\<br>0&amp;n&amp;0&amp;0\<br>?&amp;?&amp;?&amp;?\<br>0&amp;0&amp;0&amp;z<br>\end{pmatrix}<br>吗<br>？<br>$$<br>这里我们用前者表示该变换矩阵</p>
<p>到了这一步我们还需要搞清楚第三行是什么就完成了。</p>
<p>这里我们带入两点：</p>
<ol>
<li>Near clip plane上的任意点，设为(i,j,n)，它的z值变换后不变依旧为 n。</li>
<li>Far clip plane上的中心点，设为(0,0,f)，它的z值变换后不变依旧为 f。</li>
</ol>
<p>上述式子就变成了<br>$$<br>M_{persp-&gt;ortho}^{4×4}<br>\begin{pmatrix}<br>x\<br>y\<br>n\<br>1<br>\end{pmatrix}<br>&#x3D;<br>\begin{pmatrix}<br>nx\<br>ny\<br>n^2\<br>n<br>\end{pmatrix}<br>$$</p>
<p>$$<br>M_{persp-&gt;ortho}^{4×4}<br>\begin{pmatrix}<br>0\<br>0\<br>f\<br>1<br>\end{pmatrix}<br>&#x3D;<br>\begin{pmatrix}<br>0\<br>0\<br>f^2\<br>f<br>\end{pmatrix}<br>$$</p>
<p>设第三行值分别为A,B,C,D,得到方程<br>$$<br>\begin{cases}<br>Ax+By+Cn+D&#x3D;n^2\<br>Cf^2+D&#x3D;f^2<br>\end{cases}<br>$$<br>A,B&#x3D;0;<br>$$<br>Cn-n^2&#x3D;Cf-f^2<br>$$</p>
<p><em>为什么 前两个为0，听了不同的课，感觉对这里的解释大多摸棱两可，个人理解是，为了对所有点都能应用该变换矩阵，同时减少未知因素的影响。</em></p>
<p>即可算出，C&#x3D;n+f，D&#x3D;-nf，因此视锥体压缩为长方体的矩阵为（n,f）：</p>
<p>$$<br>M_{persp-&gt;ortho}^{4×4}&#x3D;<br>\begin{pmatrix}<br>n&amp;0&amp;0&amp;0\<br>0&amp;n&amp;0&amp;0\<br>0&amp;0&amp;n+f&amp;-nf\<br>0&amp;0&amp;1&amp;0<br>\end{pmatrix}<br>$$<br><em>这里就是抓住了之前我们规定的不变常量得到的</em></p>
<p>所以视锥体内的一点压缩后的z<code>坐标会有变化吗？ $$ z</code>&#x3D;(n+f)*z-nf&#x3D;nz+fz-nf&#x3D;(z-f)*n+zf(0&gt;&#x3D;n&gt;&#x3D;z&gt;&#x3D;f)<br>$$<br>z-f&gt;0, (z-f)n &lt;0,同时 zf&lt;z&lt;0</p>
<p>因此我们可以得出z&#96;&lt;z,变换后 z坐标 将会变小(右手坐标系)，即变换后离摄像机更远了。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>cjforeal</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://cjforeal.github.io/2022/10/24/%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84Game101%E6%80%BB%E7%BB%93/">https://cjforeal.github.io/2022/10/24/%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84Game101%E6%80%BB%E7%BB%93/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/game101/"># game101</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/10/28/Lua%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AD%A6%E4%B9%A0/">Lua热更新学习</a>
            
            
            <a class="next" rel="next" href="/2022/10/13/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%8B%E4%BB%B6%E4%B8%AD%E5%BF%83/">观察者模式实现及优化。</a>
            
        </section>


    </article>
</div>

  
 <div id="gitalk-container"></div>  
 <link rel="stylesheet" href="//unpkg.com/gitalk/dist/gitalk.css">

<script src="//unpkg.com/gitalk/dist/gitalk.min.js"></script>

<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>

<div id="gitalk-container"></div>

<script type="text/javascript">

 var gitalk = new Gitalk({

 clientID: '3142d3c8eafcc4ea9dd7',

 clientSecret: 'c121752e97a91b3de38ddabdfc3e219b69efbd98',

 repo: 'cjforeal.github.io',

 owner: 'cjforeal',

 admin: 'cjforeal',

 id: md5(location.pathname), 

 labels: 'Gitalk'.split(',').filter(l => l),

 perPage: 15,

 pagerDirection: 'last',

 createIssueManually: true,

 distractionFreeMode: false

 })

 gitalk.render('gitalk-container')

</script>
  


            </div>
            <footer id="footer" class="footer">
 	<div class="copyright">
 		<span>© cjforeal | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a>
 |
 <!-- 访客数量 -->
 
 <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
		<span class="site-uv">
		总访客量:
 				<i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
			</span>&nbsp;
		
	
		<span class="site-pv">
		| 总访问量:
				<i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
	</span>

 
 </span>
 	</div>
</footer>

    </div>
</body>

</html>