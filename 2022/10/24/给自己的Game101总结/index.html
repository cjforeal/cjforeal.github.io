<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="cjforeal">





<title>写给自己的Game101总结 | Cjforeal(鼻屎拌饭)</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


        
    


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">cj&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">cj&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">写给自己的Game101总结</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">cjforeal</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十月 24, 2022&nbsp;&nbsp;22:04:33</a>
                        </span>
                    
                     


                    
                        <span class="post-count">
                    Words:
                            <a href="">6.8k</a> 
                        </span>
                    

                    
                    
                        <span class="post-count">
                    Time:
                            <a href="">27min</a> 
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><ol>
<li><p>点乘<br>$$<br>\vec{a}\vec{b}&#x3D;|a||b|cos\theta<br>$$<br> 用途：求角度或者投影,两个向量多么接近，以及两个向量的前后关系</p>
</li>
<li><p>叉乘<br>$$<br>|\vec{a}\times\vec{b}|&#x3D;||a|||b||sin\theta<br>$$<br>用途：得到垂直于 a，b两向量构成的面的 向量，并且叉乘的模是两向量平行四边形的面积。可以判断两向量内外或者左右关系。  </p>
<p>例如<img src="/images/game101%E5%8F%89%E4%B9%98.png" alt="game101叉乘"></p>
<p>如何判断B在A的左侧？</p>
<p>可以A叉乘B，看得到向量是正还是负，再通过右手螺旋定则，就可以了。</p>
<p>这是一个二维生三维的升变公式。</p>
<p>AB叉AP,BC叉BP,CA叉CP  三者结果若全都一个方向则在内部，反之不在</p>
<p>平面坐标中，如何判断P点在ABC内部？</p>
<p>注意：得到的向量的方向满足于右手螺旋定则(某些的图形Api可能选左手，视情况定)，因此叉乘不满足交换律，因为结果向量的方向不同。</p>
</li>
</ol>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><ol>
<li>矩阵乘法，不存在交换律，结合律分配律存在</li>
</ol>
<p>  <img src="/images/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95.png" alt="image-20221024233926616"></p>
<ol start="2">
<li><p>矩阵转置<br>$$<br>(AB)^T &#x3D;B^TA^t<br>$$</p>
</li>
<li><p>单位矩阵，矩阵的逆 忘了的话就看线代；</p>
</li>
</ol>
<h1 id="二维变换"><a href="#二维变换" class="headerlink" title="二维变换"></a>二维变换</h1><h2 id="线性变换-Linear-Transforms"><a href="#线性变换-Linear-Transforms" class="headerlink" title="线性变换(Linear Transforms)"></a>线性变换(Linear Transforms)</h2><p><strong>如果可以用一个相同维度的矩阵乘以你的输入坐标得到输出坐标，那我们就认为这是线性变换。</strong>例如旋转，缩放。</p>
<p>求线性变换公式规则是什么？举一个求旋转矩阵公式的例子</p>
<p><img src="/images/%E5%8F%98%E6%8D%A2%E6%97%8B%E8%BD%AC.png" alt="变换旋转"></p>
<p><em><strong>注意 这里是绕原点逆时针旋转</strong></em></p>
<p>图中物体旋转，所有点都满足相同的旋转公式，所以可以找特殊点推导其旋转公式<br>$$<br>假设四边长皆为1，逆时针旋转\theta， 则右下角坐标变为，(cos\theta,sin\theta)，存在<br>$$</p>
<p>$$<br>\begin{bmatrix}<br>xˋ\\<br>yˋ<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>a&amp;b\\<br>c&amp;d<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\\<br>y<br>\end{bmatrix}<br>带入 x&#x3D;1,y&#x3D;0 ,xˋ&#x3D;cos\theta,xˋ&#x3D;sin\theta<br>$$</p>
<p>则有<br>$$<br>a+b<em>0&#x3D;cos\theta ,c+d</em>0&#x3D;sin\theta<br>$$</p>
<p>即求出 a和c ，同样我们再带入第二个点，比如左上角(-sin theta,cos theta)，即可求出 b，d<br>$$<br>\begin{bmatrix}<br>xˋ\\<br>yˋ<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>cos\theta&amp;-sin\theta\\<br>sin\theta&amp;cos\theta<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\\<br>y<br>\end{bmatrix}<br>$$<br><strong>Attention：</strong><em><strong>旋转矩阵是正交矩阵，逆矩阵与转置矩阵相同</strong></em>，带入个顺时针旋转theta角就明白了</p>
<p>也可以这样理解 ：<strong>旋转矩阵中的值即为x,y轴的单位向量旋转后的值，三维也是同样的</strong></p>
<p>没必要记，毕竟容易推导；举一反三，什么对称，缩放，切变公式也就往后稍稍了；</p>
<h2 id="齐次坐标-Homogeneous-Coordinates"><a href="#齐次坐标-Homogeneous-Coordinates" class="headerlink" title="齐次坐标(Homogeneous Coordinates)"></a>齐次坐标(Homogeneous Coordinates)</h2><p>为什么齐次坐标？</p>
<p>当我们想着把平移用矩阵的形式表示时，公式是<br>$$<br>\begin{bmatrix}<br>xˋ\\<br>yˋ<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>1&amp;0\\<br>0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\\<br>y<br>\end{bmatrix}<br>+<br>\begin{bmatrix}<br>t_x\\<br>t_y<br>\end{bmatrix}<br>$$<br><em><strong>所以平移并不是线性变换</strong></em>,这是一种仿射变换(Affine Transformations)。</p>
<p>我们不想要平移成为特例，而是想着把平移旋转缩放等一起概括，所有有了齐次坐标。</p>
<p><strong>齐次坐标</strong></p>
<p><strong>二维坐标中，我们人为的加入了第三个坐标 w，并且定义为 w只能&#x3D;1或0;</strong></p>
<p><strong>如果w&#x3D;1，坐标表示为2D的一个点，若等于0，则表示2D向量。</strong></p>
<p>因此如果我们用齐次坐标来表示平移时，就会有以下式子<br>$$<br>\begin{bmatrix}<br>xˋ\<br>yˋ\<br>wˋ<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>1&amp;0&amp;t_x\\<br>0&amp;1&amp;t_y\\<br>0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\\<br>y\\<br>1<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>x+t_x\\<br>y+t_y\\<br>1<br>\end{bmatrix}<br>$$<br>发现仅用矩阵乘法就可以很好的表示位移，就很舒服。****</p>
<p>w的定义规则有一定原因</p>
<ol>
<li><p>为了保证向量不变性，即不管怎么平移向量，向量大小即方向不改变，我们使其w&#x3D;0</p>
</li>
<li><p>为了符合点与点之间，向量与向量之间，点与向量之间的运算关系</p>
<table>
<thead>
<tr>
<th>vector+vector&#x3D;vector</th>
<th></th>
<th>向量之和仍为向量 其中w一直是0</th>
</tr>
</thead>
<tbody><tr>
<td>vector+point&#x3D;vector</td>
<td></td>
<td>点加向量表示点的平移，w&#x3D;1+0&#x3D;1符合</td>
</tr>
<tr>
<td>point-point&#x3D;vector</td>
<td></td>
<td>两点之差为向量，w&#x3D;1-1&#x3D;0符合</td>
</tr>
<tr>
<td>那两点之和是什么？</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>有一点point(x,y,w)，我们将w转为1，同时除以w得point(x&#x2F;w,y&#x2F;w,1)，加上另外一点(x`&#x2F;w,y`&#x2F;w,1)两点相加后得到<br>$$<br>\frac{x+x<code>&#125;&#123;w&#125;, \frac&#123;y+y</code>}{w},<br>2<br>$$</p>
<p>w仍要为1，所以再除以2得到<br>$$<br>\frac{x+x<code>&#125;&#123;2w&#125;, \frac&#123;y+y</code>}{2w},<br>1<br>$$<br>显然，得到了一个中点。</p>
<p><strong>所以在齐次坐标中，两点相加表示两点的中点.</strong></p>
<p>并且齐次坐标系下，点乘以任一非零实数仍为相同的点。</p>
</li>
</ol>
<p>在齐次坐标下的缩放旋转和平移</p>
<p><img src="/images/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E8%A1%A8%E7%A4%BA.png" alt="齐次坐标表示"></p>
<h2 id="组合变换"><a href="#组合变换" class="headerlink" title="组合变换"></a>组合变换</h2><p><img src="/images/%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2.png" alt="组合变换"></p>
<p>如图，显然这个物体是经过两次变换到新二张图，又由于矩阵乘法不满足交换律，所以是先旋转还是先平移就会有区别。</p>
<p>通过计算得知，先旋转再平移是符合结果的；<br>$$<br>T_{(1,0)}\cdot R_{45}<br>\begin{bmatrix}<br>x\\<br>y\\<br>1<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>1&amp;0&amp;1\\<br>0&amp;1&amp;0\\<br>0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>cos45&amp;-sin45&amp;0\\<br>sin45&amp;cos45&amp;0\\<br>0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\\<br>y\\<br>1<br>\end{bmatrix}<br>$$<br><em><strong>注意，组合变换公式的计算顺序是从右到左的，即先把输入坐标与右一 到右二 直到左一3x3矩阵逐个计算</strong></em></p>
<p>当然，矩阵乘法满足结合律1，我们也可以先计算所有变换矩阵，再把其结果与输入坐标进行计算。</p>
<p><strong>当我们要绕非原点进行旋转时一般是将图形平移到旋转点为原点，再绕原点旋转，然后再平移回去即可</strong></p>
<p>组合变换表示为<br>$$<br>T_{(c)}\cdot R_{(\theta)}\cdot T_{(-c)}<br>$$</p>
<h1 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h1><p>右手坐标系的情况下。</p>
<p>多了一个维度Z，其他与二维变换同样，齐次坐标规则也一致<br>$$<br>3D<br>point &#x3D;(x,y,z,1)<br>$$</p>
<p>$$<br>3D \ vector &#x3D;(x,y,z,0)<br>$$</p>
<p>w为一表示点，为0表示向量</p>
<h2 id="旋转矩阵表示"><a href="#旋转矩阵表示" class="headerlink" title="旋转矩阵表示"></a>旋转矩阵表示</h2><p>即绕三个轴旋转，这里先只考虑绕单个轴旋转，</p>
<ul>
<li><p>点绕x轴旋转，即点 x轴坐标不变(则第一行为1，0，0，0)，且y，z旋转后坐标与x轴无关(则第一列为1,0,0,0),当然也可以选择几个特殊点计算求得，所以其旋转矩阵可写为<br>$$<br>R_{x}(\alpha)&#x3D;<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;0\\<br>0&amp;cos\alpha&amp;-sin\alpha&amp;0\\<br>0&amp;sin\alpha&amp;cos\alpha&amp;0\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p>
</li>
<li><p>点绕z轴旋转，同上规则<br>$$<br>R_{z}(\alpha)&#x3D;<br>\begin{bmatrix}<br>cos\alpha&amp;-sin\alpha&amp;0&amp;0\\<br>sin\alpha&amp;cos\alpha&amp;0&amp;0\\<br>0&amp;0&amp;1&amp;0\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p>
</li>
<li><p>点绕y轴旋转有些不同,我的理解就是，绕y轴逆时针旋转对于xz平面其实是顺时针旋转，所以应为-alpha<br>$$<br>R_{z}(\alpha)&#x3D;<br>\begin{bmatrix}<br>cos\alpha&amp;0&amp;sin\alpha&amp;0\\<br>0&amp;1&amp;0&amp;0\\<br>-sin\alpha&amp;0&amp;cos\alpha&amp;0\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$<br>所以三维空间内任意一个绕任意轴的旋转都可以由绕xyz旋转组合而成。<br>$$<br>R_{(\vec{n},\alpha)}&#x3D;R_{(\vec{x},\alpha x)}\cdot R_{(\vec{y},y\alpha)}\cdot R_{(\vec{z},\alpha z)}<br>$$<br>而由于其分解和运算的过程很麻烦，就有了罗德里格斯旋转方程。</p>
</li>
</ul>
<h2 id="罗德里格斯旋转方程-Rodrigues"><a href="#罗德里格斯旋转方程-Rodrigues" class="headerlink" title="罗德里格斯旋转方程(Rodrigues)"></a>罗德里格斯旋转方程(Rodrigues)</h2><p>PASS~</p>
<h1 id="三维到二维"><a href="#三维到二维" class="headerlink" title="三维到二维"></a>三维到二维</h1><p>从三维到二维有一个既定的过程，举一个现实中的栗子，摆拍</p>
<p>摆拍首先得把人和物带到拍照的位置，就是平移缩放旋转等操作，这就是<strong>模型变换(Model Transformation)</strong>.</p>
<p>摆好相机的位置和相机的朝向，这就是 <strong>视图变换(View Transformation)</strong>.</p>
<p>然后开始拍照，就存在一个三维到二维投影的过程，这就是<strong>投影变换(Projection Transformation)</strong>.</p>
<p> 三个合称<strong>MVP变换</strong>，得到的结果为<strong>MVP变换矩阵</strong>。</p>
<h2 id="视图变换"><a href="#视图变换" class="headerlink" title="视图变换"></a>视图变换</h2><p>视图变换目的在于把所有物体变换到目标位置。这里得变换矩阵是根据<strong>摄像机</strong>变换得来的。</p>
<p>相机基础属性有三个：</p>
<ol>
<li>位置 <strong>e</strong>(x,y,z)</li>
<li>朝向 <strong>g</strong></li>
<li>相对相机的正上方向量  <strong>t</strong></li>
</ol>
<p>我们要摆放相机，这里有一个约定俗成的规定：</p>
<p>相机位置位于（0，0，0），朝向为-<strong>z</strong>(0,0,-1)  ，正上方向量为<strong>y</strong>(0,1,0)，</p>
<p>为什么，因为好处多多。</p>
<p>所以我们需要进行以下变换</p>
<ul>
<li>将相机坐标<strong>e</strong>平移到原点</li>
<li>旋转<strong>g</strong>到**-z**</li>
<li>旋转<strong>t</strong>到<strong>y</strong></li>
<li>旋转<strong>g × t</strong> 到 <strong>x</strong>(1,0,0)</li>
</ul>
<p>首先平移矩阵最好写<br>$$<br>T_{(VIEW)}&#x3D;<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;-x_e\\<br>0&amp;1&amp;0&amp;-y_e\\<br>0&amp;0&amp;1&amp;-z_e\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$<br> 然后就是三个旋转，</p>
<p>这里为了计算方便：选择逆向思维，我们先求-z到g，y到t，x到g x t的 这三个单位向量的旋转矩阵，得到的结果组合起来就是目标旋转矩阵的逆矩阵，然后又因为旋转矩阵是正交矩阵，所以将结果转置，就是我们要的目标矩阵了.</p>
<p>又因为，旋转矩阵中的值即为x,y,z三个轴的单位向量旋转后的值</p>
<p>所以计算结果逆矩阵为<br>$$<br>R_{VIEW}^{-1}&#x3D;<br>\begin{bmatrix}<br>x_{\vec{g}\times\vec{t}}&amp;x_\vec{t}&amp;x_{-\vec{g}}&amp;0\\<br>y_{\vec{g}\times\vec{t}}&amp;y_\vec{t}&amp;y_{-\vec{g}}&amp;0\\<br>z_{\vec{g}\times\vec{t}}&amp;z_\vec{t}&amp;z_{-\vec{g}}&amp;0\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$<br>转置一下就是目标旋转矩阵了<br>$$<br>R_{VIEW}&#x3D;<br>\begin{bmatrix}<br>x_{\vec{g}\times\vec{t}}&amp;y_{\vec{g}\times\vec{t}}&amp;z_{\vec{g}\times\vec{t}}&amp;0\\<br>x_\vec{t}&amp;y_\vec{t}&amp;z_\vec{t}&amp;0\\<br>x_{-\vec{g}}&amp;y_{-\vec{g}}&amp;z_{-\vec{g}}&amp;0\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p>
<p>所以<strong>视图变换矩阵</strong>为<br>$$<br>R_{VIEW}T_{(VIEW)}&#x3D;<br>\begin{bmatrix}<br>x_{\vec{g}\times\vec{t}}&amp;y_{\vec{g}\times\vec{t}}&amp;z_{\vec{g}\times\vec{t}}&amp;0\\<br>x_\vec{t}&amp;y_\vec{t}&amp;z_\vec{t}&amp;0\\<br>x_{-\vec{g}}&amp;y_{-\vec{g}}&amp;z_{-\vec{g}}&amp;0\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;-x_e\\<br>0&amp;1&amp;0&amp;-y_e\\<br>0&amp;0&amp;1&amp;-z_e\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p>
<h2 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h2><p>投影变换分为两种</p>
<ul>
<li>正交投影（Orthographic projection）</li>
<li>透视投影（Perspective     projection）</li>
</ul>
<p>两者共有的属性</p>
<ul>
<li><p>Near clip plane 和Far clip plane</p>
<p>两者分别代表摄像机看见的最近平面和最远平面，两平面间的空间就是我们能看见的</p>
<p>正交投影为这个空间近似于长方体，透视投影则时像个椎体，成为视锥体</p>
</li>
<li><p>由于之前的视图变化，使得计算更加简便</p>
</li>
<li><p>摄像机看向z还是-z不同图形软件可能不同，如opengl就是右手坐标系，unity是左手坐标系</p>
<p>投影变换判断前后时若再右手坐标系下，越近的物体，z越大。</p>
</li>
</ul>
<p>之前开发2d游戏时对于视角的探索已经让我对两者有了很清晰的认识，现在来学习怎么实现的</p>
<h2 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h2><p><img src="/images/%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1.png" alt="正交投影"></p>
<p>如图 正交投影的特点是没有透视关系，近切面与远切面大小相同。</p>
<p>而它的投影过程通俗来讲的话，就是一个压缩的过程：</p>
<p>可视空间内的物体x,y坐标不变，将z坐标舍弃，形成一个二维平面，再将平面移动拉伸到一个左下角为(-1,-1),右上角为（1，1）的矩形中。</p>
<p><em>为什么要映射在-1<del>1的矩形内，这是一个约定俗成的东西，相当于我们拍照，规定洗出的照片都得是2×2大小的，学opengl时学到一个标准化设备坐标系，范围也是-1</del>1，两者也对应起来了。</em></p>
<p>规范点说法是：将上诉摄像机所观测的空间（即长方体，设为 S ）变换成一个<strong>标准立方体</strong>（<strong>canonical cube</strong>）。</p>
<p>何为标准立方体？即以原点为中心，边长为2的立方体，也就是立方形在x，y，z三个轴上都是从-1到1。</p>
<p>整个变换过程就是我们的<strong>正交投影变换</strong>，其对应矩阵即为正交投影变换矩阵。该变换我们可以分为如下两步（这也体现了视图变换的重要性，使得我们做投影变换变得很简单）：</p>
<ol>
<li>平移变换，将长方体S平移到原点。</li>
<li>缩放变换，将长方体S的长宽高缩放成2</li>
</ol>
<p>所以有正交投影变换矩阵（r,l,t,b,n,f 两两成对，分别为  近切面x,y,z最小及最大坐标）;<br>$$<br>M_{ortho}&#x3D;<br>\begin{bmatrix}<br>\frac{2}{r-l}&amp;0&amp;0&amp;-x_e\\<br>0&amp;\frac{2}{t-b}&amp;0&amp;-y_e\\<br>0&amp;0&amp;\frac{2}{n-f}&amp;-z_e\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;-\frac{r+l}{2}\\<br>0&amp;1&amp;0&amp;-\frac{t+b}{2}\\<br>0&amp;0&amp;1&amp;-\frac{n+f}{2}\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p>
<blockquote>
<p><em>这里遗留了一个问题：没了z坐标 ，怎么判断物体的前后？</em></p>
</blockquote>
<h2 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h2><p><img src="/images/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1.png" alt="透视投影"></p>
<p>与正交投影不同的是，透视投影会有近大远小的现象，这种投影更有真实感。从图中我们可以看出远切面要大于近切面，因此我们摄像机所观测的区域不再是一个长方体，而是变成了一个四棱台（即四棱锥去掉顶部），也就是我们常说的<strong>视锥体</strong>（Frustum）。</p>
<p>所以透视投影是个什么过程呢？</p>
<p>它分为两个过程</p>
<ul>
<li>第一步是将视锥体压缩成长方体的过程</li>
<li>第二步是对长方体执行正交投影变换的过程、</li>
</ul>
<p>那么我们只需要计算出第一步的变换矩阵，然后将它乘以正交投影变换矩阵，即可得到我们的透视投影变换矩阵了。</p>
<p>第一步个人理解就相当于把视锥体切分成n个截面，把每一个截面都压缩成近切面的大小。</p>
<p>第一步有以下规定，</p>
<ul>
<li>近切面永远是不变的，四个顶点都是设置好的常量</li>
<li>远切面的z值不论变换前后都是不变的。</li>
<li>透视中心点是不会变化的</li>
</ul>
<p>所以该如何挤压呢？我们以挤压y坐标为例</p>
<p><img src="/images/y%E5%9D%90%E6%A0%87%E6%8A%95%E5%BD%B1.png" alt="y坐标投影"></p>
<p>如图，我们从竖切面下手，取压缩面上的一点（x,y,z）,再取近切面上的对应点为（x`,y`,z`）,设摄像机到近切面的距离为n(已知常量)，</p>
<p>我们要求y`的表达式，这里有很明显的一对相似三角形，存在关系<br>$$<br>y<code>=\frac&#123;n&#125;zy $$ 同样的道理，对xz切面作近似三角形，得出x</code>的表达式<br>$$<br>x&#96;&#x3D;\frac{n}zx<br>$$</p>
<p>因此在齐次坐标下就有了如下转换过程<br>$$<br>\begin{pmatrix}<br>x\<br>y\<br>z\<br>1<br>\end{pmatrix}<br>&#x3D;&gt;^{相似}<br>\begin{pmatrix}<br>\frac{n}zx\\<br>\frac{n}zy\\<br>?\\<br>1<br>\end{pmatrix}<br>&#x3D;&gt;^{*z}<br>\begin{pmatrix}<br>nx\\<br>ny\\<br>?\\<br>z<br>\end{pmatrix}<br>$$</p>
<blockquote>
<p><em>为什么想到要同时乘z，因为z是变量</em></p>
<p><em>有个问题，z坐标压缩后不应该还是z吗？怎么不知道？留待后面说，实际会变大</em></p>
</blockquote>
<p>所以也就存在一个4x4的变换矩阵使得<br>$$<br>M_{persp-&gt;ortho}^{4×4}<br>\begin{pmatrix}<br>x\\<br>y\\<br>z\\<br>1<br>\end{pmatrix}<br>&#x3D;<br>\begin{pmatrix}<br>nx\\<br>ny\\<br>?\\<br>z<br>\end{pmatrix}<br>$$<br>计算得到该矩阵<br>$$<br>M_{persp-&gt;ortho}^{4×4}&#x3D;<br>\begin{pmatrix}<br>n&amp;0&amp;0&amp;0\\<br>0&amp;n&amp;0&amp;0\\<br>?&amp;?&amp;?&amp;?\\<br>0&amp;0&amp;1&amp;0<br>\end{pmatrix}<br>。。。。。。<br>可以是这个<br>\begin{pmatrix}<br>n&amp;0&amp;0&amp;0\\<br>0&amp;n&amp;0&amp;0\\<br>?&amp;?&amp;?&amp;?\\<br>0&amp;0&amp;0&amp;z<br>\end{pmatrix}<br>吗<br>？<br>$$<br>这里我们用前者表示该变换矩阵</p>
<p>到了这一步我们还需要搞清楚第三行是什么就完成了。</p>
<p>这里我们带入两点：</p>
<ol>
<li>Near clip plane上的任意点，设为(i,j,n)，它的z值变换后不变依旧为 n。</li>
<li>Far clip plane上的中心点，设为(0,0,f)，它的z值变换后不变依旧为 f。</li>
</ol>
<p>上述式子就变成了<br>$$<br>M_{persp-&gt;ortho}^{4×4}<br>\begin{pmatrix}<br>x\\<br>y\\<br>n\\<br>1<br>\end{pmatrix}<br>&#x3D;<br>\begin{pmatrix}<br>nx\\<br>ny\\<br>n^2\\<br>n<br>\end{pmatrix}<br>$$</p>
<p>$$<br>M_{persp-&gt;ortho}^{4×4}<br>\begin{pmatrix}<br>0\\<br>0\\<br>f\\<br>1<br>\end{pmatrix}<br>&#x3D;<br>\begin{pmatrix}<br>0\\<br>0\\<br>f^2\\<br>f<br>\end{pmatrix}<br>$$</p>
<p>设第三行值分别为A,B,C,D,得到方程<br>$$<br>\begin{cases}<br>Ax+By+Cn+D&#x3D;n^2\\<br>Cf^2+D&#x3D;f^2<br>\end{cases}<br>$$<br>A,B&#x3D;0;<br>$$<br>Cn-n^2&#x3D;Cf-f^2<br>$$</p>
<blockquote>
<p><em>为什么 前两个为0，听了不同的课，感觉对这里的解释大多摸棱两可，个人理解是，为了对所有点都能应用该变换矩阵，同时减少未知因素的影响。</em></p>
</blockquote>
<p>即可算出，C&#x3D;n+f，D&#x3D;-nf，因此视锥体压缩为长方体的矩阵为（n,f）：</p>
<p>$$<br>M_{persp-&gt;ortho}^{4×4}&#x3D;<br>\begin{pmatrix}<br>n&amp;0&amp;0&amp;0\\<br>0&amp;n&amp;0&amp;0\\<br>0&amp;0&amp;n+f&amp;-nf\\<br>0&amp;0&amp;1&amp;0<br>\end{pmatrix}<br>$$</p>
<blockquote>
<p><em>这里就是抓住了之前我们规定的不变常量得到的</em></p>
</blockquote>
<p>所以视锥体内的一点压缩后的z<code>坐标会有变化吗？ $$ z</code>&#x3D;(n+f)*z-nf&#x3D;nz+fz-nf&#x3D;(z-f)*n+zf(0&gt;&#x3D;n&gt;&#x3D;z&gt;&#x3D;f)<br>$$<br>z-f&gt;0, (z-f)n &lt;0,同时 zf&lt;z&lt;0</p>
<p>因此我们可以得出z&#96;&lt;z,变换后 z坐标 将会变小(右手坐标系)，即变换后离摄像机更远了。</p>
<h2 id="屏幕映射"><a href="#屏幕映射" class="headerlink" title="屏幕映射"></a>屏幕映射</h2><p>结果前面的处理，我们得到了一个三维空间下的标准立方体[-1, 1]³，我们需要将他转到屏幕坐标系下，屏幕有以下特点</p>
<ul>
<li>屏幕是光栅成像设备，其成像点通常理解为二维数组，数组元素为像素。</li>
<li>屏幕坐标系原点此处为左下角(0,0)，定义宽度width，和高度height。</li>
<li>对于屏幕上像素，其位置为(x, y)，其像素中心点的坐标是(x+0.5, y+0.5)。</li>
</ul>
<p>先不管它的Z轴数据（由深度缓冲来处理），屏幕映射需要<strong>将X和Y轴 [-1, 1]² 映射到屏幕坐标 [0, width] x [0, height]<strong>，屏幕原点一般在左下角，通过齐次坐标的矩阵，先将 <strong>[-1, 1]² 缩放至 [width, height]，</strong>再平移使得原点坐标对齐，将标准立方体转换成屏幕空间，变换矩阵为</strong>：</strong><br>$$<br>M_{}^{4×4}&#x3D;<br>\begin{pmatrix}<br>\frac {width}2&amp;0&amp;0&amp;\frac {width}2\\<br>0&amp;\frac {height}2&amp;0&amp;\frac {height}2\\<br>0&amp;0&amp;1&amp;0\\<br>0&amp;0&amp;0&amp;1<br>\end{pmatrix}<br>$$</p>
<h1 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h1><p>光栅化的目的在于将之前输出的数据包括 计算处理得到片元。就是要计算出每一个像素的RGB值。其工作主要是</p>
<ol>
<li><p>三顶点读取，两两连接，形成三角形。</p>
</li>
<li><p>采样，遍历像素点，判断哪些像素位于三角形内</p>
</li>
<li><p>循环每个三角形，直到结束</p>
</li>
</ol>
<blockquote>
<p>为什么是三角形？</p>
<p>这是由其特性决定的：</p>
<ul>
<li>是最基础的多边形，任何多边形都可由三角形组成</li>
<li>内外定义清晰(叉积)</li>
<li>方便插值运算,通过三个顶点得出三角形内部的属性。(重心坐标)</li>
</ul>
</blockquote>
<h2 id="判断像素位于三角形内"><a href="#判断像素位于三角形内" class="headerlink" title="判断像素位于三角形内"></a>判断像素位于三角形内</h2><p><strong>叉积</strong></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>显然没必要判断所有像素</p>
<ol>
<li><p><strong>AABB包围盒</strong></p>
<p>三角形三个顶点xy的最大最小值，由该四个值形成一个包围盒，只判断包围盒内的像素即可。</p>
</li>
<li><p><strong>增量横扫</strong></p>
<p>参考知乎文章<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/126365249">三角形光栅化</a>。</p>
</li>
</ol>
<h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><blockquote>
<p>采样是指：对一个函数，用一组离散值作为输入得到函数的一组离散值作为输出，将函数离散化的过程。</p>
</blockquote>
<p>在判断像素是否位于三角形内时，我们利用了像素的概念，这就是采样的运用</p>
<p><strong>而当我们采样频率比不上信号变化的速率时将会导致一些问题，这就是走样</strong>。</p>
<p>包括锯齿（像素采样）摩尔纹（空间采样）车轮效应（时间采样）</p>
<h2 id="走样"><a href="#走样" class="headerlink" title="走样"></a>走样</h2><p>探讨为什么产生走样就要了了解这些关键词：</p>
<p>傅里叶级数展开，傅里叶变换<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aW4y1y7Hs/?spm_id_from=333.337.search-card.all.click&vd_source=40c05ccabd427bd5c6b9f1b86d398745">李永乐简单讲解傅里叶</a>和可视化展示<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pW411J7s8/?spm_id_from=333.337.search-card.all.click&vd_source=40c05ccabd427bd5c6b9f1b86d398745">形象展示傅里叶变换</a></p>
<p>二维图片的傅里叶级数展开和傅里叶变化，空域频域和如何品鉴频域图<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/99605178">图像傅里叶变换)</a></p>
<p>图像卷积</p>
<p>简单说下结论：</p>
<p>傅里叶级数意思就是任何周期性函数都可以展开为多个正（余）弦函数的组合，对于周期无法分明的函数我们认为其周期时正负无穷</p>
<p>傅里叶变换结果就是展开的结果频域，当然可以逆变换。</p>
<p>空域卷积等于频域乘积。滤波通过卷积实现</p>
<p>走样本质就是频域发生了重叠导致</p>
<h2 id="走样的解决方案"><a href="#走样的解决方案" class="headerlink" title="走样的解决方案"></a>走样的解决方案</h2><p>各种抗锯齿方案主要了解MSAA,有兴趣了解TAA,FXAA,SUPER RESOLUTION</p>
<h1 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h1><blockquote>
<p>当我们讨论着色器的时候，着色器在想什么？</p>
<p>它在想这个地方我要什么颜色，这个地方明暗是怎么样的？</p>
</blockquote>
<p>着色：对一个物体应用一个材质的过程，它不考虑阴影。</p>
<h2 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h2><blockquote>
<p>这里讨论的是Blinn-Phong模型,简化了反射时的吸收等其他影响要素</p>
</blockquote>
<p><img src="/images/light.png" alt="light"></p>
<p>如图，一个物体的受光一般分为三部分，从上倒下依次是</p>
<ul>
<li><strong>镜面高光(Specular Highlights)</strong></li>
<li><strong>漫反射(Diffuse Reflection)</strong></li>
<li><strong>环境光(Ambient Light)</strong></li>
</ul>
<h3 id="光照的局部模型"><a href="#光照的局部模型" class="headerlink" title="光照的局部模型"></a>光照的局部模型</h3><p><strong>对于局部一点的光照，通常采用极限思想，即一束极小的光从光源发出，撞到极小的一点反射到观察者眼中。</strong></p>
<p>由上可知其需要三点</p>
<ul>
<li>光源&#x2F;入射光线， 定义为单位向量<strong>l</strong></li>
<li>反射面&#x2F;法向量,    定义为单位向量<strong>n</strong></li>
<li>观察者&#x2F;反射光线 ,定义为单位向量<strong>v</strong></li>
</ul>
<p>正如下图</p>
<p><img src="/images/view.png" alt="view"></p>
<h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3><blockquote>
<p>在量子光学中，光的能量是量子化的，我们称光的量子为光量子</p>
<p>个人对量子光学的理解也只停留在高中物理课上的光电效应等程度上，但也够了</p>
</blockquote>
<p> <img src="/images/%E6%BC%AB%E5%8F%8D%E5%B0%84.png" alt="1"></p>
<p>如图,漫反射定义为入射光向四面八方反射强度相同的光。反射光互不平行。</p>
<p>虽然这是张平面图，但是反射是立体的，正如尾兽玉爆炸时的扩散。</p>
<p>反射光的强度和入射光相比明显是更小的，这里影响系数是入射光和法向量的夹角θ的余弦(兰伯特定律Lambert’s Law)，就像使夏天太阳光直射北回归线，冬天直射南回归线时的强度变化。</p>
<p>我们设入射光强度为<strong>I</strong>，则反射光强为<br>$$<br>Icosθ<br>$$<br>此外还有第二个影响要素，在真空环境下，在漫反射光的传播过程中，能量分布相当于是从小球壳到大球壳的传播的过程，根据能量守恒定律，小球壳上能量和大球壳上的能量是相等的，因此，大球壳单位面积上的能量就会更小，这里就存在一个单位面积光强和表面积的反比关系，设观察者离漫反射点的距离为<strong>R</strong>，则有<br>$$<br>Icosθ&#x2F;r^2<br>$$</p>
<p>综合以上有漫反射公式<br>$$<br>L_{diffuse}&#x3D;\frac{I}{R^2}max(0,cosθ)<br>$$<br>加上物体表面漫反射系数k，并带入<strong>n,l</strong>,得到最终公式<br>$$<br>L_{diffuse}&#x3D;k_d\frac{I}{R^2}max(0,\vec n\cdot \vec l)<br>$$</p>
<h3 id="高光"><a href="#高光" class="headerlink" title="高光"></a>高光</h3><p>着色点材质较光滑时，反射接近镜面反射（但也仅是接近），与漫反射强度分析一致，分两步，反射后的强度衰减，反射光传播中的强度衰减，其中后者是相同的道理，这里需要明白前者。</p>
<p>通俗理解，什么情况下，其强度会更强？那就是反射光越接近理论上的镜面反射光的时候，也就是说，观察者的观测向量越接近镜面反射光时，观测到的高光越强，计算接近程度时用两向量点乘。</p>
<p><img src="/images/%E9%AB%98%E5%85%89.png" alt="高光"></p>
<p>如图，定义镜面反射光为<strong>m</strong>，入射光强为<strong>I</strong>所以高光反射强度为<br>$$<br>I \vec v\cdot \vec m<br>$$<br>加上第二步中的公式，以及考虑物体表面高光反射系数k得到Phong模型下的高光公式<br>$$<br>L_s&#x3D;k_s(\frac{I}{R^2})max(0,\vec m\cdot \vec v)^p<br>$$<br>这里加个指数P是为了控制高光反射面积的大小和能够看到高光的范围。当<em>p</em>的值越大，反射面积(能看到高光的范围)越小。</p>
<p>Blinn-Phong模型简化了镜面反射光的计算，经验化的转成了通过计算半程向量<strong>h</strong>和法向量<strong>n</strong>的接近程度。半程向量就是角平分线向量，四边形法则相加后单位化再即可<br>$$<br>\vec h&#x3D;\frac {\vec v +\vec l} {|\vec v +\vec l|}<br>$$</p>
<p>所以有高光反射公式<br>$$<br>L_s&#x3D;k_s(\frac{I}{R^2})max(0,\vec n\cdot \vec h)^p<br>$$</p>
<h3 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h3><p>环境光就是从四面八方反射到来的光，这些光都有各自丰富的故事，很是复杂，这里大胆的假设光强全都一致(后续有全局光照，光追等)<br>$$<br>L_a&#x3D;k_aI_a<br>$$<br>通常就是材质的RGB数值。</p>
<p>就这样把三个公式加起来就得到了Blinn-Phong模型的光照公式<br>$$<br>L&#x3D;k_d\frac{I}{R^2}max(0,\vec n\cdot \vec l)+k_s(\frac{I}{R^2})max(0,\vec m\cdot \vec v)^p+k_aI_a<br>$$</p>
<h2 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h2><p>分为三种，也就是三种不同的着色算法</p>
<ul>
<li><p>Flat Shading 逐片元着色</p>
<p>根据每个三角形的法向量着色。</p>
</li>
<li><p>Gouraud Shading 逐顶点着色</p>
<p>通过计算顶点所关联的面的法向量的平均来求得顶点法向量，再通过对三个顶点着色结果的线性插值计算得到片元的着色.</p>
</li>
<li><p>Phong Shading 逐像素着色</p>
</li>
</ul>
<h2 id="纹理-Texture-贴图-Map-映射-Mapping"><a href="#纹理-Texture-贴图-Map-映射-Mapping" class="headerlink" title="纹理(Texture) |贴图(Map)|映射(Mapping)"></a>纹理(Texture) |贴图(Map)|映射(Mapping)</h2><p>上述解决了着色时明暗问题，但是不同着色点的属性不一定相同，比如颜色，漫反射高光反射系数，为了解决这个问题，我们使用<strong>纹理</strong>。<strong>纹理就是着色点的属性，属性一词就包括了各式各样的数据，就是上面说的颜色，反射系数等数据。</strong></p>
<p>而一个3D物体的表面有各式各样的着色点，如果我们把它的表面展开，就如下图</p>
<p><img src="/images/%E7%BA%B9%E7%90%86.png" alt="纹理"></p>
<p>我们把右一图上某一点的纹理应用到了左一渲染图上的对应点，而这个过程，我们就称为<strong>纹理映射</strong>。右一图上保存着所有着色点的纹理和其他数据，如uv坐标等，这个图我们就称为<strong>贴图</strong>。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>cjforeal</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://cjforeal.github.io/2022/10/24/%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84Game101%E6%80%BB%E7%BB%93/">https://cjforeal.github.io/2022/10/24/%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84Game101%E6%80%BB%E7%BB%93/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/game101/"># game101</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/10/28/Lua%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AD%A6%E4%B9%A0/">Lua热更新学习</a>
            
            
            <a class="next" rel="next" href="/2022/10/13/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%8B%E4%BB%B6%E4%B8%AD%E5%BF%83/">观察者模式实现及优化。</a>
            
        </section>


    </article>
</div>

  
 <div id="gitalk-container"></div>  
 <link rel="stylesheet" href="//unpkg.com/gitalk/dist/gitalk.css">

<script src="//unpkg.com/gitalk/dist/gitalk.min.js"></script>

<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>

<div id="gitalk-container"></div>

<script type="text/javascript">

 var gitalk = new Gitalk({

 clientID: '3142d3c8eafcc4ea9dd7',

 clientSecret: 'c121752e97a91b3de38ddabdfc3e219b69efbd98',

 repo: 'cjforeal.github.io',

 owner: 'cjforeal',

 admin: 'cjforeal',

 id: md5(location.pathname), 

 labels: 'Gitalk'.split(',').filter(l => l),

 perPage: 15,

 pagerDirection: 'last',

 createIssueManually: true,

 distractionFreeMode: false

 })

 gitalk.render('gitalk-container')

</script>
  


            </div>
            <footer id="footer" class="footer">
 	<div class="copyright">
 		<span>© cjforeal | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a>
 |
 <!-- 访客数量 -->
 
 <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
		<span class="site-uv">
		总访客量:
 				<i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
			</span>&nbsp;
		
	
		<span class="site-pv">
		| 总访问量:
				<i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
	</span>

 
 </span>
 	</div>
</footer>

    </div>
</body>

</html>