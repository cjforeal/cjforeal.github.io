<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="cjforeal">





<title>游戏《占地之王》 | Cjforeal</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">cj&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">cj&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">游戏《占地之王》</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">cjforeal</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">六月 17, 2022&nbsp;&nbsp;11:13:58</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Unity/">Unity</a>
                            
                        </span>
                     


                    
                        <span class="post-count">
                    Words:
                            <a href="">1.9k</a> 
                        </span>
                    

                    
                    
                        <span class="post-count">
                    Time:
                            <a href="">8min</a> 
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="《占地为王》代码清单"><a href="#《占地为王》代码清单" class="headerlink" title="《占地为王》代码清单"></a>《占地为王》代码清单</h1><p>游戏主要参考泡泡堂，就占地盘，为大二下学期期末作业。</p>
<p>需求：多人游戏，多人Ui，四个地图，四个道具，有练习模式等等。</p>
<p>源码已上传  （<a target="_blank" rel="noopener" href="https://github.com/cjforeal/GameProject"><strong>github</strong></a>）  </p>
<p>UnityVersion : 2020.3.19f1c2.</p>
<h3 id="主要重点"><a href="#主要重点" class="headerlink" title="主要重点"></a>主要重点</h3><h4 id="1-根本玩法填涂色块之色块衔接"><a href="#1-根本玩法填涂色块之色块衔接" class="headerlink" title="1.根本玩法填涂色块之色块衔接"></a>1.根本玩法填涂色块之色块衔接</h4><ul>
<li><p>需求分析：色块衔接的流动性，加分以及减去其他玩家分数，角色自己色块衔接的同时影响其他角色的色块</p>
</li>
<li><p>为了更好的实现目标设计了以下程序和结构</p>
<ul>
<li><p>声明一个父类<code>BasicPlayer</code>静态字典<code>public static Dictionary&lt;PlayerFlag, TileBase[][]&gt; playTile;</code>键为角色的枚举<code>PlayerFlag</code>，值为每一个子类所特有的用来保存瓦片的交错数组<code>public TileBase[][] Tiles;</code></p>
</li>
<li><p>色块一共有七种，考虑方向大概有每名角色有20不同色块</p>
<ul>
<li>直接上图<img src="/images/%E5%8D%A0%E5%9C%B0%E4%B9%8B%E7%8E%8B%E5%9B%BE1.png" alt="图1"></li>
</ul>
<p>​		<img src="/images/%E5%8D%A0%E5%9C%B0%E4%B9%8B%E7%8E%8B%E5%9B%BE2.png" alt="图2"></p>
<p>大致代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">public void JudegNowPos(TileBase[][] tiles,Vector3 pos,ref PlayerFlag oldFlag)</span><br><span class="line">&#123;</span><br><span class="line">    TileBase tile = tilemap.GetTile(tilemap.WorldToCell(pos));</span><br><span class="line">    if (!ContainsTile(tiles, tile))</span><br><span class="line">    &#123;</span><br><span class="line">        scores++;</span><br><span class="line">        foreach (PlayerFlag p in playTile.Keys)</span><br><span class="line">        &#123;</span><br><span class="line">            if (p == this.playerFlag) continue;</span><br><span class="line">            if (ContainsTile(playTile[p],tile))</span><br><span class="line">            &#123;</span><br><span class="line">                PlayerManager.Instance.playingPlayers[(int)p-1].GetComponent&lt;BasicPlayer&gt;().scores--;</span><br><span class="line">                oldFlag = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//对玩家上下左右进行色块判定</span><br><span class="line"> public  void TestFloor(TileBase[][] tiles,Vector3 pos)</span><br><span class="line">    &#123;</span><br><span class="line">        int[] dir = &#123; 0, 0, 0, 0 &#125;;</span><br><span class="line">        int num = 0;</span><br><span class="line">        for(int i=0;i&lt;4; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (ContainsTile(tiles, tilemap.GetTile(tilemap.WorldToCell(pos+vector3[i]))))</span><br><span class="line">            &#123;</span><br><span class="line">                dir[i]++;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        switch (num)</span><br><span class="line">        &#123;</span><br><span class="line">            case 0: tilemap.SetTile(tilemap.WorldToCell(pos), tiles[num][0]); break;</span><br><span class="line">            case 1:</span><br><span class="line">                int i;</span><br><span class="line">                for (i = 0; i &lt; 4; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (dir[i] != 0) break;</span><br><span class="line">                &#125;</span><br><span class="line">                tilemap.SetTile(tilemap.WorldToCell(pos), tiles[num][i]);</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                if (dir[0] == dir[2]&amp;&amp;dir[0]==1)      tilemap.SetTile(tilemap.WorldToCell(pos), tiles[num][0]); </span><br><span class="line">                else if (dir[1] == dir[3]&amp;&amp;dir[1]==1) tilemap.SetTile(tilemap.WorldToCell(pos), tiles[num][1]); </span><br><span class="line">                else </span><br><span class="line">                &#123;</span><br><span class="line">                    int k ;</span><br><span class="line">                    bool exist = false;</span><br><span class="line">                    for ( k = 0; k &lt; 4; k++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (dir[k%4] == dir[(k + 1)%4]&amp;&amp;dir[k]==1)</span><br><span class="line">                        &#123;</span><br><span class="line">                            exist = ContainsTile(tiles, tilemap.GetTile(tilemap.WorldToCell(pos + vector3[k+4])));</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;               </span><br><span class="line">                    if(!exist) tilemap.SetTile(tilemap.WorldToCell(pos), tiles[5][k]);</span><br><span class="line">                    else tilemap.SetTile(tilemap.WorldToCell(pos), tiles[6][k]);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                int j ;</span><br><span class="line">                for (j = 0; j &lt; 4; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (dir[j] == 0) break;</span><br><span class="line">                &#125;</span><br><span class="line">                tilemap.SetTile(tilemap.WorldToCell(pos), tiles[num][j]);</span><br><span class="line">                break;</span><br><span class="line">            case 4: tilemap.SetTile(tilemap.WorldToCell(pos), tiles[num][0]); break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      public void TestAroundFloor(TileBase[][] tiles,Vector3 pos ,PlayerFlag oldFlag)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;vector3.Length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector3 vector = pos + vector3[i];</span><br><span class="line">            TileBase tile = tilemap.GetTile(tilemap.WorldToCell(vector));</span><br><span class="line">            if (ContainsTile(tiles, tile))</span><br><span class="line">            &#123;</span><br><span class="line">                TestFloor(tiles, vector);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(oldFlag != PlayerFlag.NoHost&amp;&amp; ContainsTile(playTile[oldFlag],tile))</span><br><span class="line">            &#123;</span><br><span class="line">                TestFloor(playTile[oldFlag],vector);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;```</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-四个地图"><a href="#2-四个地图" class="headerlink" title="2.四个地图"></a>2.四个地图</h4><ul>
<li>猪图 生成猪群冲撞，协程控制生成，传入<code>isRight</code>参数控制生成方位和重写动画状态机</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator CreatePig(bool IsRight)</span><br><span class="line">&#123;</span><br><span class="line">    yield return new WaitForSeconds(5f);</span><br><span class="line">    while(true)</span><br><span class="line">    &#123;   </span><br><span class="line">        for(int i=0;i&lt;num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Instantiate(pig).GetComponent&lt;PigRush&gt;().isRight = IsRight; </span><br><span class="line">            IsRight = !IsRight;</span><br><span class="line">            yield return new WaitForSeconds(0.5f);</span><br><span class="line">        &#125;         </span><br><span class="line">        yield return new WaitForSeconds(rushTime);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>冰图 冰面滑步效果，玩家进入冰面Trigger切换其移动方式为刚体施力。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(other.CompareTag(&quot;Icy&quot;))</span><br><span class="line">   &#123;</span><br><span class="line">       moveMode = 1;</span><br><span class="line">   &#125;</span><br><span class="line"> public void MoveByMoveMode(int m)</span><br><span class="line">   &#123;</span><br><span class="line">       if(m==0) rigidBody.MovePosition(rigidBody.position + inputMove * speed * 		Time.fixedDeltaTime);</span><br><span class="line">       else rigidBody.AddForce(inputMove * speed );</span><br><span class="line">   &#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li>糖图 就是简单的随机数生成，如果该<code>position</code>没有障碍物，则生成。</li>
</ul>
<h4 id="3-四个道具"><a href="#3-四个道具" class="headerlink" title="3.四个道具"></a>3.四个道具</h4><ul>
<li><p>飞刀  实现很简单，如果碰到了敌人，切换敌人脚本上的色块就好</p>
<p>方向根据释放道具玩家脚本上保留的“正前方”<code>Forward</code>来改变</p>
<pre><code>  public void Movement(InputAction.CallbackContext ctx)
 &#123;       
      if(ctx.performed)
      &#123;
          inputMove = ctx.ReadValue&lt;Vector2&gt;();
          animPlayer.SetFloat(&quot;Vertical&quot;, inputMove.y);
          animPlayer.SetFloat(&quot;Horizonal&quot;, inputMove.x);
          Forward = inputMove;
           &#125;
if(ctx.canceled)
  &#123;
      float angle = Vector2.SignedAngle(Vector2.right, inputMove);
      if (angle &gt; -45 &amp;&amp; angle &lt;= 45) Forward = Vector2.right;
      else if (angle &gt; 45 &amp;&amp; angle &lt;= 135) Forward = Vector2.up;
      else if (angle &gt; 135 || angle &lt;= -135) Forward = Vector2.left ;
      else if(angle &gt; -135 &amp;&amp; angle &lt;= -45) Forward = Vector2.down;
      inputMove = new Vector2(0, 0);
  &#125;
&#125;
</code></pre>
</li>
<li><p>跑鞋 移速加倍，可穿过障碍物，对手，糖，和猪，</p>
<ul>
<li><p>因为不能使玩家穿透空气墙故通过改变<code>layer</code>的方式来改变碰撞，此前需要在<code>ProjectSetting</code>里设置<code>layer</code>之间的碰撞关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">speed = 10;</span><br><span class="line">    GameObject BoostEffect = Resources.Load&lt;GameObject&gt;(&quot;Effect/BoostEffect&quot;);</span><br><span class="line">    Destroy(Instantiate(BoostEffect, transform.position, Quaternion.identity,transform), boostTime);</span><br><span class="line">    gameObject.layer = LayerMask.NameToLayer(&quot;Boost&quot;);</span><br><span class="line">    yield return new WaitForSeconds(boostTime);</span><br><span class="line">    speed = 5;</span><br><span class="line">    gameObject.layer = LayerMask.NameToLayer(&quot;Default&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>透明药水 实现简单，改变其他玩家状态，无法涂色</p>
</li>
<li><p>炸弹 实现简单，随机数将地图上的瓦片替换为施放者去角色瓦片即可</p>
</li>
</ul>
<h4 id="4-多人游戏和多人UI控制"><a href="#4-多人游戏和多人UI控制" class="headerlink" title="4.多人游戏和多人UI控制"></a>4.多人游戏和多人UI控制</h4><ul>
<li><p>多人UI控制</p>
<p>开始游戏只生成一名<code>MultiplayeEventSystem</code>并保存下来，选择角色时其余玩家通过按键来生成自己定义的<em>UIcontroler</em>预制体（绑定了UI控制组件），之后使其失去选择物直到准备界面再重新赋予其选择物，在unity的组件帮助下还算便利。</p>
</li>
<li><p>UI层级变化 定义了一个Ui栈 ，到下一层则令<code>Stack.Peek()</code>失活，并使下一层进栈，返回上一层则令其先出栈且使其失活，在激活栈顶物体</p>
</li>
<li><p>多人游戏在<code>PlayerinputManager</code>的帮助下比较简单，值得注意的就是要保留生成<em>UIcontroler</em>时的设备.</p>
<pre><code>这是三种获取输入设备的方法
//Debug.Log(playerInput.user.pairedDevices[0]);
// Debug.Log(playerInput.devices[0] );
//Debug.Log(playerInput.GetDevice&lt;Gamepad&gt;());
 然后再开始游戏时通过这样来生成角色
 public static PlayerInput Instantiate(GameObject prefab, int playerIndex = -1, string controlScheme = null, int splitScreenIndex = -1, params InputDevice[] pairWithDevices);
</code></pre>
</li>
</ul>
<h3 id="其余功能与细节"><a href="#其余功能与细节" class="headerlink" title="其余功能与细节"></a>其余功能与细节</h3><ol>
<li><h4 id="玩家选择人物问题"><a href="#玩家选择人物问题" class="headerlink" title="玩家选择人物问题"></a>玩家选择人物问题</h4><ul>
<li><p>问题1：如果使用按钮的点击回调事件，导致每名玩家都需要给四个角色按钮动态绑定点击函数，以至于每次点击一次该按钮下绑定的四个函数都会调用，更何况事件内的函数调用与否无法控制，结果就是四个人选的一样的人物，所以通过人为检测的办法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void BindCharacter(InputAction.CallbackContext ctx)</span><br><span class="line">&#123;   </span><br><span class="line">    if(ctx.action.name==&quot;Submit&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        if (eventSystem.currentSelectedGameObject == null) return;</span><br><span class="line">        else if (Opening.StackPeek.name== &quot;ChooseChar&quot; &amp;&amp; ctx.started)</span><br><span class="line">        &#123;</span><br><span class="line">            switch (eventSystem.currentSelectedGameObject.name[6])</span><br><span class="line">            &#123;</span><br><span class="line">                case &#x27;1&#x27;: PlayerManager.Instance.joinPlayers[DeviceId] = PlayerManager.Instance.players[0]; break;</span><br><span class="line">				......</span><br><span class="line">            &#125;</span><br><span class="line">            eventSystem.currentSelectedGameObject.GetComponent&lt;Button&gt;().interactable = false;</span><br><span class="line">            eventSystem.sendNavigationEvents = false;</span><br><span class="line">            PlayerManager.Instance.existChar[DeviceId] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还是选择人物问题，如果此时两名玩家选择的物体是相同的，一名玩家点击确认，使得该角色按钮<code>Interactable</code>取消，导致另一名玩家<code>EventSystem</code>大几率选择物丢失，或者选择为空，	<code>UI Navigation</code>报错，解决办法如下，递归实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void SetSelectinChooseChar(Button button,int length)</span><br><span class="line">   &#123;</span><br><span class="line">       int i = button.gameObject.name[6]-&#x27;0&#x27;;</span><br><span class="line">       if (!button.interactable)</span><br><span class="line">           SetSelectinChooseChar(Opening.Buttons[i%length],length);    </span><br><span class="line">       else</span><br><span class="line">           eventSystem.SetSelectedGameObject(button.gameObject);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h4 id="观察者模式和单例模式的应用"><a href="#观察者模式和单例模式的应用" class="headerlink" title="观察者模式和单例模式的应用"></a>观察者模式和单例模式的应用</h4><p>单例脚本<code>PlayerManager</code>（切换场景不可销毁），用来管理玩家和UI，关卡等关系，同时也是一名观察者，定义了<code>event BeginPlay（）</code>，选择地图时添加委托，在每局准备界面玩家皆准备时自动调用，也要注意每局结束要删除之前添加的事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">例如         BeginPlaying -= LoadPigEvent;</span><br><span class="line">            BeginPlaying -= LoadIceEvent;</span><br><span class="line">            BeginPlaying -= LoadCandyEvent;</span><br><span class="line">            BeginPlaying -= LoadBlankEvent;</span><br><span class="line">            //显示Ready画面</span><br><span class="line">            transform.GetChild(0).GetChild(0).gameObject.SetActive(true);</span><br><span class="line">            transform.GetChild(0).GetChild(1).gameObject.SetActive(true);</span><br><span class="line">            SetSelectInReadyMenu();</span><br><span class="line">            BasicPlayer.playTile.Clear();</span><br><span class="line">            int x = Random.Range(0, 4);</span><br><span class="line">            switch (x)</span><br><span class="line">            &#123;</span><br><span class="line">                case 0:</span><br><span class="line">                    BeginPlaying += LoadPigEvent;</span><br><span class="line">                    MapIntroduction.sprite = Resources.Load&lt;Sprite&gt;(&quot;MapIntroduction/Pigmap&quot;);</span><br><span class="line">                    SceneManager.LoadScene(&quot;PigMapTest&quot;, LoadSceneMode.Additive);</span><br><span class="line">                    break;</span><br><span class="line">                ......</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>(单例虽好，但不要滥用，有时候记得清理单例对象的变量，同时时时刻刻清楚其生命周期，如同对待静态变量对待他)</p>
</li>
<li><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库 "></a>数据库 <br></h4><p>用于保存玩家获胜，获胜局数，最高分，总分等信息</p>
</li>
<li><h4 id="场景异步加载以及它的加载完成后的委托事件应用"><a href="#场景异步加载以及它的加载完成后的委托事件应用" class="headerlink" title="场景异步加载以及它的加载完成后的委托事件应用"></a>场景异步加载以及它的加载完成后的委托事件应用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">	public void LoadBlankEvent()</span><br><span class="line"> &#123;</span><br><span class="line">     AsyncOperation aa = SceneManager.LoadSceneAsync(&quot;Blank&quot;);</span><br><span class="line">     aa.completed += EventAfterSceneLoaded;</span><br><span class="line"> &#125;</span><br><span class="line"> private void EventAfterSceneLoaded(AsyncOperation a)</span><br><span class="line"> &#123;</span><br><span class="line">    ......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><h4 id="练习模式"><a href="#练习模式" class="headerlink" title="练习模式"></a>练习模式</h4><p>首先添加附加场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SceneManager.LoadScene(&quot;BlankTest&quot;, LoadSceneMode.Additive);</span><br></pre></td></tr></table></figure>

<p>练习场景里的Camera设<code>Targic</code>设置为<code>Renderer Texture</code>与Ui上的<code>rawimage</code>对应就好</p>
</li>
</ol>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>cjforeal</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://cjforeal.github.io/2022/06/17/Grade2FinalWork/">https://cjforeal.github.io/2022/06/17/Grade2FinalWork/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Unity%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95/"># Unity游戏代码清单</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/06/18/Unity%E9%9A%8F%E7%AC%941/">unity笔记1之Awake和OnEnable 的顺序</a>
            
            
            <a class="next" rel="next" href="/2022/06/16/%E5%AD%97%E5%85%B8%E9%81%8D%E5%8E%86%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B7%AE%E5%88%AB/">字典遍历的方法以及差别</a>
            
        </section>


    </article>
</div>

  
 <div id="gitalk-container"></div>  
 <link rel="stylesheet" href="//unpkg.com/gitalk/dist/gitalk.css">

<script src="//unpkg.com/gitalk/dist/gitalk.min.js"></script>

<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>

<div id="gitalk-container"></div>

<script type="text/javascript">

 var gitalk = new Gitalk({

 clientID: '3142d3c8eafcc4ea9dd7',

 clientSecret: 'c121752e97a91b3de38ddabdfc3e219b69efbd98',

 repo: 'cjforeal.github.io',

 owner: 'cjforeal',

 admin: 'cjforeal',

 id: md5(location.pathname), 

 labels: 'Gitalk'.split(',').filter(l => l),

 perPage: 15,

 pagerDirection: 'last',

 createIssueManually: true,

 distractionFreeMode: false

 })

 gitalk.render('gitalk-container')

</script>
  


            </div>
            <footer id="footer" class="footer">
 	<div class="copyright">
 		<span>© cjforeal | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a>
 |
 <!-- 访客数量 -->
 
 <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
		<span class="site-uv">
		总访客量:
 				<i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
			</span>&nbsp;
		
	
		<span class="site-pv">
		| 总访问量:
				<i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
	</span>

 
 </span>
 	</div>
</footer>

    </div>
</body>

</html>